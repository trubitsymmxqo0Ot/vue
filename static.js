/*
	Во vue также можно валидировать пропсы, которые мы получаем внутрь компонента. 
	Перед тем, как перейти к этой теме. Хочу затронуть стиль написания. Представим себе пропс isOpen, который 
	нужно передать внутрь другого компонента. Дело в том, что внутрь компонента мы можем получать пропс
	с помощью camelCase стиля написания, лучше всего всегда использовать такой стиль написания для работы с
	js, т.к. символ - он не сможет обработать. А вот когда мы передаем этот пропс и пишем его внутри html,
	то лучше использовать cebabCase (is-open), т.к. он ближе всего к html.

	И так, вернемся к валидации. Мы можем явно указывать какой именно тип данных может принимать в себя каждый
	пропс, для этого делается объект в методе props, а не массив и далее мы пишем пару, где ключ - это наш
	пропс, а значение - это его тип данных, который мы передаем внутрь. Также, в качетсве типов данных мы
	можем использовать и Proxy, и Array, и Promise. Если же мы передадим тип данных, который не соответствует
	написанному нами, то в таком случае vue кинет warning нам в консоль.

	Помимо этого, можно валидировать пропсы более тонко, для этого, в качетсве значения самого пропса
	нужно открыть новый объект, куда принимаются пары: type, required, default, validator.

	С помощью type мы указываем тип данных, который передается через пропс.
	С помощью required мы указываем, обязателен ли этот тип данных.
	С помощью validator мы можем валидировать какие-то значения, где через return также возращается булевый тип
	данных, если будет true - значит валидация прошла успешно (даже если сам пропс возращает false, он отработал
	правильно, так что для поля validate - это true), а false - это значит, что при отрабатывании пропса 
	произошла какая-то ошибка.
	С помощью default мы можем указать какое-то значение по дефолту для того или инога пропса. Важное уточнение,
	что дефолтное значение уставливается если мы указали, что required false, то есть, если пропс не является
	обязательным в компоненте.

	Также, очень важное уточнение, что все пропсы являются readonly, это можно исправить с помощью v-model,
	getters или $emit, однако, в видео автор смог реализовать изменение пропса isOpen без этих доп функции,
	в связи с чем я пока что вырезал из кода этот кусок, т.к. такое поведение может объясняться в дальнейшем.

	Далее все примеры в коде.
*/