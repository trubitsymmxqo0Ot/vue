const h = Vue.h;
const app = Vue.createApp({
  data() {
    return {
      title: "Это title из свойства template",
    };
  },
  methods: {
    changeTitle() {
      this.title = "Изменили";
    },
  },
  render() {
    return h(
      "div",
      {
        class: "card",
      },
      [
        h("h1", {
			class: "card__title"
		}, this.title),
        h("button", {
          class: "card__second-tilte",
		  onClick: this.changeTitle,
        }, 'Изменить'),
      ]
    );
  },
  // template: `
  // 	<div class="card">
  // 		<h1 class="card__title">{{ title }}</h1>
  // 		<button class="card__second-title" @click="title = 'Изменили'">Изменить</button>
  // 	</div>
  // `
});

app.mount("#root");

/*
	Очень важный отступ от темы. Во vue реактивность достигается немного другим способом, нежели чем в react, 
	на самом деле, реактивность достигается с помощью proxy и сеттеров. Внутри прокси просто перезаписывается
	ключ на новое значение, которое мы указали.

	Далее, мы будем говорить о стадиях жизни компонента, его монтирование и уничтожение. Важно понимать, что 
	многие из методов, которые будут озвучены, можно полноценно использовать внутри createApp.

	Саму статью можно посмотреть вот тут - https://vuejs.org/guide/essentials/lifecycle.html, тут также будет
	график, в котором указывается полный цикл жизни компонента.

	1) В самую первую очередь начинается сам рендер, эта статия называется Render encountres component, в момент
	начала рендера у нас подягивается setup или composition API, также, срабатывает первый метод beforeCreate,
	к этому методу мы можем обратиться. То есть, в самом начале у нас срабатывает createApp и mount, компонент
	начинает монтироваться в DOM дерево.

	2) Затем у нас идет стадия init Options API, это стадия, в которой у нас окончательно подтягивается API
	vue. Внутри этой стадии можно использовать метод created. В момент срабатывания стадии происходит условное 
	ветвление, которое называется Has pre-complited template? Если ответ no, тогда будет дополнительная стадия,
	она называется compile template on-the-fly, если же ответ был yes то стадия продолжает свою и работу и в 
	самом конце этой стадии активируется метод beforeMount, с ним мы также можем взаимодействовать. Грубо говоря,
	на этой стадии идет проверка, есть ли какие-то монтированные компоненты (html код), если нет, то тогда
	монтирование происходит со стороны vue (если есть соответствующий код), если есть, то vue просто отловил
	тег, который был монтирован и идет по пирамиде рендеринга далее.
	
	3)	Следующая стадия называется Initial render create & instert DOM nodes эта стадия нужна для того, чтобы 
	окончательно монтировать объекты в html документ, либо считать их. В момент срабатывания стадии нам
	доступен метод mounted, с помощью которого мы можем отловить это окончательное монтирование. Метод достаточно
	большой, на самом деле, поэтому пойдем по порядку.

	3.1) На этом этапе у нас появляется доступ к Virtual DOM, это отдельный процесс и называется re-render and patch,
	но он тесно связан с процессом из 3 пунка, т.к. обновление или добавление происходит в уже существующий узел DOM.
	Внутри самого процесса также есть 2 метода: 1.beforeUpdate - мы можем с ним взаимодествовать и с его помощью
	можем что-либо сделать до обновления компонента, 2.updated - мы также можем работать с этим методов и он
	нужен для того, чтобы что-то сделать сразу после обновления.

	3.2) Этот этап называется точно также, как и в пунке 3, но он срабатывает только в момент уничтожения компонента.
	У него есть 2 метода, с которыми мы можем взаимодействовать: beforeUnmount - служит для того, чтобы что-либо
	сделать перед уничтожением компонента и unmounted - служит для того, чтобы сделать что-то сразу после удаления
	(в момент)
*/
