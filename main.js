const App = {
	data: () => ({
		title: 'Что-то',
		myHtmlTag: '<div class="myHtmlTag">Это мой кастомный тег</div>',
		address: {
			city: "Moscow",
			country: "Russia",
		},
		items: [1,2,3,4,5,6],
	})
}
Vue.createApp(App).mount('#root');

/*
	Перед началом, хочу немного отойти от темы. Предстаим такую ситуацию, что мы реализовали удаление элементов из массива, как в коммите назад (или два, не помню точно),
	там у нас просто список от 1 до 6, который даже не кнопки, а список, при нажатии на которые они удаляются из массива. Но если нам добавить input внутри этого li, то 
	при нажатии на input у нас будет всплытие события и элемент будет удален. Но что если нам не нужно такое поведение? Тогда мы можем сделать метод storPropagation 
	внутри js, внутри него обратиться к event и отключить ему всплытие, а затем через директиву @click заюзать этот метод.

	Однако, во vue есть модификатор на этот случай. Мы уже рассматривали модификатор prevent, который отключает preventDefault, однако во vue есть модификатор и для 
	отключения всплытия, он называется stop, синтаксис будет таким: @click.stop. Более того, мы можем модификаторы соединять в одну цепочку: @click.stop.prevent.

	Я поднимал тему того, что во vue используется тот же самый концепт virtualDOM, как и в React. Зная реакт, я понимаю, что при использовании цикла всегда обязательно
	нужно использовать key для того, чтобы virtualDOM точно мог определить место каждого элемента в массиве и чтобы не возникало багов. Один из багов: если мы возьмем 
	пример выше, где у нас можно удалять поле из массива и там ещё есть input с отключенным всплытием. То есть мы попытаемся что-то вписать в input, а затем удалить 
	этот объект, то тогда объект удалится, однако содержимое input перескочит на следующий элемент. На самом же деле, дело в том, что vue удаляет не тот элемент, 
	на который мы нажали, а последний элемент из списка, а затем просто перерисовывает цифры, чтобы визуально казалось, что он удалил именно то, на что нажали мы.

	Такое поведение сделано в целях экономии ресурсов, т.к. всегда намного проще что-то добавить в конце массива или удалить. Т.к. если это делать в середине или 
	начале массива, то сначала js придется сдвинуть все элемента массива на 1 больше, затем поменять у них индексы и добавить новый элемент, это операция будет очевидно
	тяжелее, чем просто взять или убрать с конца, однако, если мы укажем key, тогда мы точно будем говорить где какой элемент находится в списке и благодаря этому
	удаление будет происходить по конкретному элементу.

	сам по себе метод key нужно будет байндить с помощью v-bind и вписывать туда уникальное значение. idx мы не можем передать, т.к. по доке React я знаю, что если не указать
	метод key, то он будет указан автоматически на фоне, а в качестве уникальных ключей будет использовать индекс элемента в массиве (что тоже не рекомендуется делать),
	но мы можем указать сам item в качестве key, т.к. у нас там цифры от 1 до 6 и они все уникальны.
*/